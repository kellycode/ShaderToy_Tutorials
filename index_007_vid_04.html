<!-- source: The Art of Code https://youtu.be/jKuXA0trQPE?list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5 -->

<!-- rectangle to wavey rectangle with blur on one side -->

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
        <style>
            body {
                margin: 0px;
                margin: 0;
                background-color: #000;
                color: #fff;
                font-family: Monospace;
                font-size: 13px;
                line-height: 24px;
                overscroll-behavior: none;
            }
        </style>
        <!-- Upgraded THREE -->
        <script type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.js"
                }
            }
        </script>
        <script type="module">
            import * as THREE from "three";
            runExample(THREE);
        </script>
    </head>

    <body>
        <div id="container"></div>

        <script id="vertexShader" type="x-shader/x-vertex">
            // so far the shadertoy vids don't mention
            // vertex shader but this works to start
            void main()	{
                gl_Position = vec4( position, 1.0 );
                // from three js examples and also works, no idea why
                // gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">
            uniform float time;
            uniform vec2 resolution;

            float Circle(vec2 uv, vec2 p, float r, float blur) {
                float d = length(uv-p);
                float c = smoothstep(r, r-blur, d);

                return c;
            }

            float Band(float t, float start, float end, float blur) {
                float step1 = smoothstep(start - blur, start + blur, t);
                float step2 = smoothstep(end + blur, end - blur, t);

                return step1 * step2;
            }

            float Rect(vec2 uv, float left, float right, float bottom, float top, float blur) {
                float band1 = Band(uv.x, left, right, blur);
                float band2 = Band(uv.y, bottom, top, blur);

                return band1 * band2;
            }

            float Smiley(vec2 uv, vec2 p, float size) {
                uv -= p; // translating coordinate system
                uv /= size; // scale the coordinate system

                // make the circle with no offset
                float mask = Circle(uv, vec2(0.0, 0.0), 0.4, 0.015);

                // left eye
                mask -= Circle(uv, vec2(-0.15, 0.15), 0.07, 0.01);
                // right eye
                mask -= Circle(uv, vec2(0.15, 0.15), 0.07, 0.01);

                float mouth = Circle(uv, vec2(0.0, 0.0), 0.3, 0.015);
                mouth -= Circle(uv, vec2(0.0, 0.1), 0.3, 0.015);

                mask -= mouth;

                return mask;
            }

            float remap01  ( float a, float b, float t) {
                return (t-a) / (b-a);
            }

            float remap  ( float a, float b, float c, float d, float t) {
                return remap01(a, b, t) * (d-c) + c;
            }

            void main()	{
                vec2 uv = gl_FragCoord.xy / resolution.xy; // 0 to 1
                float t = time;
                uv -= 0.5;
                uv.x *= resolution.x/resolution.y;

                // color
                vec3 col = vec3(0.0);

                float mask = 0.0;

                float x = uv.x;

                // our time here is fast so slow it down
                //t = t/20.0;
                float m = sin((t/20.0) + x * 8.0) * 0.1;
                float y = uv.y - m;

                float blur = remap(-0.5, 0.5, 0.01, 0.25, x);
                blur = pow(blur, 2.0);

                mask = Rect(vec2(x, y), -0.5, 0.5, -0.1, 0.1, blur );

                // black
                col = vec3(1.0, 1.0, 1.0) * mask;

                gl_FragColor = vec4(col, 1.0);
            }
        </script>
        <script>
            let runExample = function (THREE) {
                let container;
                let camera, scene, renderer;
                let uniforms, material, mesh;

                init();
                // not used atm
                let startTime = Date.now();
                animate();

                function init() {
                    container = document.getElementById("container");

                    // a Three.Camera, so not perspective or orthographic and
                    // this seems to be a place holder camera and not actually
                    // used since the screen is displaying the shader material only
                    camera = new THREE.Camera();
                    // position can be 0, -+1 or -+2 but no larger, no clue why
                    // since we don't seem to belooking at anything in the scene
                    // and the shaders render directtly to the canvas

                    scene = new THREE.Scene();

                    uniforms = {
                        time: { type: "f", value: 1.0 },
                        resolution: { type: "v2", value: new THREE.Vector2() },
                    };

                    material = new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: document.getElementById("vertexShader").textContent,
                        fragmentShader: document.getElementById("fragmentShader").textContent,
                    });

                    // never seen but required, for something to attach a material to?
                    mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
                    scene.add(mesh);

                    renderer = new THREE.WebGLRenderer();
                    // ( 1 ) to keep the canvas the same size as the window
                    // setSize uses devicePixelRatio and, so far, it makes the canvas
                    // larger than the window and that makes the shader coordinates
                    // larger than the window and distorts the image if I don't
                    // compnsate by setting the uv (uv -= 0.5;) offset to match
                    renderer.setPixelRatio( 1 );
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.domElement.width = window.innerWidth;
                    renderer.domElement.height = window.innerHeight;
                    container.appendChild(renderer.domElement);

                    uniforms.resolution.value.x = window.innerWidth;
                    uniforms.resolution.value.y = window.innerHeight;
                }

                function animate() {
                    // continue rendering is not really neded since the shader
                    // only requires one render pass atm
                    requestAnimationFrame(animate);
                    render();
                }

                function render() {
                    let elapsedMilliseconds = Date.now() - startTime;
                    let elapsedSeconds = elapsedMilliseconds / 1000;
                    uniforms.time.value = 60 * elapsedSeconds;
                    renderer.render(scene, camera);
                }
            };
        </script>
    </body>
</html>

<!--
Vector length: 

Vector Length in WebGL

In WebGL, the length of a vector refers to its Euclidean distance, which is calculated as the square root of the sum of the squares of its components. For a vector $v(x, y, z)$, the length is computed as $\sqrt{x^2 + y^2 + z^2}$

WebGL uses GLSL (OpenGL Shading Language) for shader programs, and GLSL includes a built-in function `length` that calculates the length of a vector. This function works with vectors of letious dimensions, such as `vec2`, `vec3`, and `vec4`, and returns the Euclidean distance of the vector

The `length` function in GLSL is designed to operate on vectors and applies to each component of the vector, returning a single value representing the length of the vector

In summary, the length of a vector in WebGL is the Euclidean distance of its components, and it can be easily calculated using the built-in `length` function in GLSL

Is used for:

The length of a vector is a fundamental concept in computer graphics and is used for a letiety of purposes in WebGL. Here are some common applications:

1. **Normalization**:
   - **Purpose**: To convert a vector into a unit vector (a vector with a length of 1).
   - **Usage**: Normalization is often required in lighting calculations, where the direction of a vector is important but its magnitude is not. For example, normal vectors in surface shading are typically normalized to ensure consistent lighting results.
   - **Example**: `vec3 normalizedVector = normalize(v);`

2. **Distance Calculation**:
   - **Purpose**: To determine the distance between two points in 3D space.
   - **Usage**: This is useful in collision detection, camera positioning, and other spatial calculations.
   - **Example**: `float distance = length(a - b);`

3. **Scaling**:
   - **Purpose**: To scale a vector by a scalar value while maintaining its direction.
   - **Usage**: This is useful in letious transformations, such as moving objects in a scene.
   - **Example**: `vec3 scaledVector = v * scalar;`

4. **Lighting and Shading**:
   - **Purpose**: To calculate the intensity of light on a surface.
   - **Usage**: The length of vectors like the light direction and surface normal is used in letious lighting models, such as diffuse and specular lighting.
   - **Example**: `float diffuse = max(dot(normalize(lightDirection), normalize(surfaceNormal)), 0.0);`

5. **Camera Control**:
   - **Purpose**: To manage the position and orientation of the camera.
   - **Usage**: The length of vectors can be used to control the camera's distance from objects or to adjust the field of view.
   - **Example**: `vec3 cameraPosition = targetPosition + normalize(cameraDirection) * distance;`

6. **Collision Detection**:
   - **Purpose**: To determine if two objects are within a certain distance of each other.
   - **Usage**: The length of the vector between the centers of two objects can be compared to their combined radii to detect collisions.
   - **Example**: `bool collision = length(centerA - centerB) < (radiusA + radiusB);`

7. **Particle Systems**:
   - **Purpose**: To control the behavior of particles in a particle system.
   - **Usage**: The length of velocity vectors can be used to determine the speed of particles and to apply forces like gravity or wind.
   - **Example**: `float speed = length(velocity);`

8. **Physics Simulations**:
   - **Purpose**: To simulate physical behaviors like gravity, friction, and collisions.
   - **Usage**: The length of force vectors can be used to apply forces to objects and to calculate their resulting motion.
   - **Example**: `vec3 acceleration = force / mass;`

In summary, the length of a vector is a versatile tool in WebGL, used for normalization, distance calculation, scaling, lighting, camera control, collision detection, particle systems, and physics simulations.

-->
